USE WebStor;
/*
Напишемо запит, який поверне дані продукту з найбільшою довжиною (за кількістю символів) опису. 
Врахуємо ймовірність того, що одразу кілька товарів можуть мати однакову кількість символів в описі.
Використаємо таблицю [dbo].[PRODUCTS];
Застосуємо строкову функцію `LEN`;
Результируючий набір даних міститиме: Ідент. виробника, ідент. продукту, опис продукту, довжину опису.
Для порівняння вихідної таблиці та таблиці, сформованої за запитом спочатку вкажемо запит на вихідну таблицю.
*/
--Виконання завдання:
SELECT * FROM [dbo].[PRODUCTS];
SELECT TOP 1 
    (p.MFR_ID),
    (p.PRODUCT_ID),
    (p.DESCRIPTION),
    LEN(p.Description) AS DESCRIPTION_LENGTH
FROM [dbo].[PRODUCTS] [p]
ORDER BY LEN(p.Description) DESC;
--У результаті отримуємо бажаний резкльтат запиту, все працює.

/*
Напишемо запит, що повертає дані продуктів, ідентифікатор яких містить лише цифри. 
Склеїмо значення стовпців (конкатенація): MFR_ID, PRODUCT_ID, [DESCRIPTION]. Врахуйте, що між значеннями стовпців має бути лише один пробіл. При необхідності видалимо хвостові пробіли.
Порахуємо кількість символів у сконкатенованому рядку. Видалимо дублюючі рядки у результуючому наборі даних.
Використаємо таблицю [dbo].[PRODUCTS];
Застосуємо предикат `NOT LIKE`, строкові функції( `CONCAT_WS`, `UPPER`, `LEN`, `RTRIM`);
Результируючий набір даних міститиме: сконкатенований рядок, довжина сконкатенованого рядка;
Відсортуємо результируючий набір даних за довжиною сконкатенованого рядка (за зменшенням).
Для порівняння вихідної таблиці та таблиці, сформованої за запитом спочатку вкажемо запит на вихідну таблицю.
*/
--Виконання завдання:
SELECT * FROM  [dbo].[PRODUCTS];
SELECT DISTINCT
    CONCAT_WS(' ', RTRIM(MFR_ID), RTRIM(PRODUCT_ID), RTRIM([DESCRIPTION])) AS CONCATENATED_STRING,
    LEN(CONCAT_WS(' ', RTRIM(MFR_ID), RTRIM(PRODUCT_ID), RTRIM([DESCRIPTION]))) AS STRING_LENGTH
FROM [dbo].[PRODUCTS]
WHERE PRODUCT_ID NOT LIKE '%[^0-9]%'
ORDER BY LEN(CONCAT_WS(' ', RTRIM(MFR_ID), RTRIM(PRODUCT_ID), RTRIM([DESCRIPTION]))) DESC;
--Все працює, завдання виконано.

/*
Напишемо запит, який поверне список клієнтів з найменшим кредитним лімітом.
Врахуємо ймовірність того, що одразу кілька клієнтів можуть мати однаковий кредитний ліміт.
Результируючий набір даних міститиме: ідент. клієнта, найменування клієнта, кредитний ліміт.
Найменування клієнта відобразимо як 2 букви на початку рядка і 2 букви в кінці рядка, всі інші букви замінити на символ *.
Використаємо таблицю [dbo].[CUSTOMERS].
Для порівняння вихідної таблиці та таблиці, сформованої за запитом спочатку вкажемо запит на вихідну таблицю.
*/
--Виконання завдання:
SELECT * FROM [dbo].[CUSTOMERS]
ORDER BY [CREDIT_LIMIT] ASC;
WITH RankedCustomers AS (
    SELECT 
        CUST_NUM,
        CONCAT(LEFT(COMPANY, 2), REPLICATE('*', LEN(COMPANY) - 4), RIGHT(COMPANY, 2)) AS MASKED_NAME,
        CREDIT_LIMIT,
        DENSE_RANK() OVER (ORDER BY CREDIT_LIMIT) AS Rank -- Використовуємо DENSE_RANK для забезпечення однакових рангів для клієнтів з однаковим кредитним лімітом
    FROM [dbo].[CUSTOMERS]
)
SELECT 
    CUST_NUM,
    MASKED_NAME,
    CREDIT_LIMIT
FROM RankedCustomers
WHERE Rank <= 1; -- Вибираємо перші рівні рангу
--Все працює, завдання виконано.

